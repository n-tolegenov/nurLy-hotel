Добавляя начальной зависимости Spring Security в спецификацию сборки проекта, вы получаете следующее:
    - все пути HTTP-запросов требуют аутентификации;
    - никаких особых ролей или полномочий не предусматривается;
    - для аутентификации предлагается простая страница входа;
    - есть только один пользователь – user.

Cредства шифрования паролей, имеющихся в составе Spring Security, включая следующие:
    - BCryptPasswordEncoder – применяет надежное шифрование bcrypt;
    - NoOpPasswordEncoder – не применяет шифрования;
    - Pbkdf2PasswordEncoder – применяет шифрование PBKDF2;
    - SCryptPasswordEncoder – применяет шифрование Scrypt;
    - StandardPasswordEncoder – применяет шифрование SHA-256.

Чтобы настроить хранилище учетных записей пользователей для их аутентификации,
нам понадобится bean-компонент UserDetailsService.
Интерфейс UserDetailsService относительно прост и имеет всего один метод, который нужно реализовать:
    - UserDetails loadUserByUsername(String username);

В Spring Security есть несколько готовых реализаций UserDetailsService, в том числе:
    - хранилище учетных записей в памяти;
    - хранилище учетных записей JDBC;
    - хранилище учетных записей LDAP.

Для управления защитой веб-запросов нужно объявить bean-компонент SecurityFilterChain:
    - public SecurityFilterChain filterChain(HttpSecurity http);

    Метод filterChain() принимает объект HttpSecurity, который действует как построитель,
    который можно использовать для настройки работы системы безопасности на веб-уровне.
    После настройки конфигурации безопасности с помощью объекта HttpSecurity вызов
    build() создаст компонент SecurityFilterChain.

    С помощью HttpSecurity можно:
        - потребовать выполнения определенных условий безопасности перед обслуживанием запроса;
        - отправить пользователю свою страницу входа;
        - предоставить пользователям возможности выйти из приложения;
        - настроить защиту от подделки межсайтовых запросов.

    Методы конфигурации, определяющие правила защиты путей:
        - access(String) Разрешает доступ, если выражение на языке Spring Expression
        - Language (SpEL) дает в результате true
        - anonymous() Разрешает доступ анонимным пользователям
        - authenticated() Разрешает доступ аутентифицированным пользователям
        - denyAll() Запрещает доступ без всяких исключений
        - fullyAuthenticated() Разрешает доступ, если пользователь полностью аутентифицирован
        (не был запомнен с помощью функции «запомнить меня»)
        - hasAnyAuthority(String...) Разрешает доступ, если пользователь обладает любой из перечисленных
        привилегий
        - hasAnyRole(String...) Разрешает доступ, если пользователь обладает любой из перечисленных
        ролей
        - hasAuthority(String) Разрешает доступ, если пользователь обладает указанной привилегией
        - hasIpAddress(String) Разрешает доступ, если запрос получен с указанного IP-адреса
        - hasRole(String) Разрешает доступ, если пользователь обладает указанной ролью
        - not() Инвертирует значение, возвращаемое предыдущим методом в цепочке
        - permitAll() Разрешает доступ всем без всяких условий
        - rememberMe() Разрешает доступ пользователям, аутентифицированным с помощью
        функции «запомнить меня»

Безопасность на уровне методов:
    - Аннотация @PreAuthorize принимает выражение SpEL,
        и если выражение дает в результате false, то метод не вызывается.
        Если выражение дает в результате true, то метод будет вызван.

        Чтобы получить возможность использовать @PreAuthorize, нужно
        включить глобальную защиту методов. Для этого следует снабдить
        класс конфигурации безопасности аннотацией @EnableGlobalMethodSecurity:
        @EnableGlobalMethodSecurity.

    - Аннотация @PostAuthorize
       действует почти так же, как @PreAuthorize, но ее выражение вычисляется только
       после вызова целевого метода. Это позволяет использовать в выражении значение,
       возвращаемое методом, и учитывать его при принятии решения.

Есть несколько способов определить пользователя. Вот некоторые наиболее распространенные:
    - внедрить объект java.security.Principal;
    - внедрить объект org.springframework.security.core.Authentication;
    - использовать org.springframework.security.core.context.SecurityContextHolder, чтобы получить контекст безопасности;
    - внедрить параметр метода с аннотацией @AuthenticationPrincipal

Spring Security, вводя классы фильтров до того, как HTTP-запросы достигнут DispatcherServlet.
Это означает, что каждый входящий запрос будет проходить через эти классы фильтров один за другим.
Этот подход позволяет нам проверять состояния аутентификации и авторизации до того,
как запрос достигнет контроллеров, DispatcherServletа затем и контроллеров.
По сути, это основная функция Spring Security.

Основные компоненты Spring Security:
    - Security Filter Chain: Это серия фильтров, которые обрабатывают входящие HTTP-запросы и взаимодействуют с сервером Authentication Manager для проверки запросов.
    - Authentication Manager: Это центральный компонент, проверяющий личность пользователя. Он координирует процесс аутентификации и делегирует фактическую аутентификацию Authentication Providers.
    - Authentication Providers: Это работники Authentication Manager. Они несут ответственность за фактическое выполнение аутентификации.
    - UserDetailsService: Это интерфейс, который получает данные пользователя во время процесса аутентификации. Он часто используется вместе с Authentication Providers для получения данных пользователя из базы данных для аутентификации.
    - Password Encoder: Используется для безопасного хеширования и проверки паролей, поскольку хранение и сравнение паролей имеет решающее значение для аутентификации пользователя.
    - SecurityContextHolder и Principal: